/* tslint:disable */
/* eslint-disable */
/**
 * University Schedule Management API
 * API for managing university schedules, classes, user registration, and schedule generation on a weekly basis per semester.
 *
 * The version of the OpenAPI document: 1.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'dayOfWeek': EventDayOfWeekEnum;
    /**
     * Start time in HH:mm format
     * @type {string}
     * @memberof Event
     */
    'startTime': string;
    /**
     * End time in HH:mm format
     * @type {string}
     * @memberof Event
     */
    'endTime': string;
    /**
     * ID of the schedule this event belongs to
     * @type {string}
     * @memberof Event
     */
    'scheduleId': string;
    /**
     * ID of the group associated with this event
     * @type {string}
     * @memberof Event
     */
    'groupId': string;
}

export const EventDayOfWeekEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type EventDayOfWeekEnum = typeof EventDayOfWeekEnum[keyof typeof EventDayOfWeekEnum];

/**
 * 
 * @export
 * @interface GenerateScheduleRequest
 */
export interface GenerateScheduleRequest {
    /**
     * Semester for which the schedule is to be generated
     * @type {string}
     * @memberof GenerateScheduleRequest
     */
    'semester': string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Unique identifier for the group
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * Name or identifier of the group
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof Group
     */
    'subjects': Array<Subject>;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'ownerId'?: string;
    /**
     * Semester for which the schedule is valid
     * @type {string}
     * @memberof Schedule
     */
    'semester'?: string;
    /**
     * 
     * @type {Array<Event>}
     * @memberof Schedule
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * Unique identifier for the subject
     * @type {string}
     * @memberof Subject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    'name': string;
    /**
     * Number of hours per week the subject is taught
     * @type {number}
     * @memberof Subject
     */
    'hoursPerWeek': number;
}
/**
 * 
 * @export
 * @interface Teacher
 */
export interface Teacher {
    /**
     * Unique identifier for the teacher
     * @type {string}
     * @memberof Teacher
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Teacher
     */
    'subjects': Array<string>;
    /**
     * Maximum number of hours the teacher can work per week
     * @type {number}
     * @memberof Teacher
     */
    'maxHoursPerWeek': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
}

export const UserRoleEnum = {
    Student: 'student',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserRegistration
 */
export interface UserRegistration {
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    'password': string;
    /**
     * Role of the user
     * @type {string}
     * @memberof UserRegistration
     */
    'role': UserRegistrationRoleEnum;
}

export const UserRegistrationRoleEnum = {
    Student: 'student',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;

export type UserRegistrationRoleEnum = typeof UserRegistrationRoleEnum[keyof typeof UserRegistrationRoleEnum];

/**
 * 
 * @export
 * @interface V1EventsEventIdPutRequest
 */
export interface V1EventsEventIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'dayOfWeek'?: V1EventsEventIdPutRequestDayOfWeekEnum;
    /**
     * Start time in HH:mm format
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'startTime'?: string;
    /**
     * End time in HH:mm format
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'scheduleId'?: string;
    /**
     * ID of the group associated with this event
     * @type {string}
     * @memberof V1EventsEventIdPutRequest
     */
    'groupId': string;
}

export const V1EventsEventIdPutRequestDayOfWeekEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type V1EventsEventIdPutRequestDayOfWeekEnum = typeof V1EventsEventIdPutRequestDayOfWeekEnum[keyof typeof V1EventsEventIdPutRequestDayOfWeekEnum];

/**
 * 
 * @export
 * @interface V1EventsPostRequest
 */
export interface V1EventsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'dayOfWeek': V1EventsPostRequestDayOfWeekEnum;
    /**
     * Start time in HH:mm format
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'startTime': string;
    /**
     * End time in HH:mm format
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'scheduleId': string;
    /**
     * ID of the group associated with this event
     * @type {string}
     * @memberof V1EventsPostRequest
     */
    'groupId': string;
}

export const V1EventsPostRequestDayOfWeekEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type V1EventsPostRequestDayOfWeekEnum = typeof V1EventsPostRequestDayOfWeekEnum[keyof typeof V1EventsPostRequestDayOfWeekEnum];

/**
 * 
 * @export
 * @interface V1SchedulesPostRequest
 */
export interface V1SchedulesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SchedulesPostRequest
     */
    'name': string;
    /**
     * Semester for which the schedule is valid
     * @type {string}
     * @memberof V1SchedulesPostRequest
     */
    'semester': string;
}
/**
 * 
 * @export
 * @interface V1SchedulesScheduleIdPutRequest
 */
export interface V1SchedulesScheduleIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SchedulesScheduleIdPutRequest
     */
    'name'?: string;
    /**
     * Semester for which the schedule is valid
     * @type {string}
     * @memberof V1SchedulesScheduleIdPutRequest
     */
    'semester'?: string;
}
/**
 * 
 * @export
 * @interface V1UsersLoginPost200Response
 */
export interface V1UsersLoginPost200Response {
    /**
     * 
     * @type {string}
     * @memberof V1UsersLoginPost200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface V1UsersRegisterPost400Response
 */
export interface V1UsersRegisterPost400Response {
    /**
     * 
     * @type {string}
     * @memberof V1UsersRegisterPost400Response
     */
    'message'?: string;
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdDelete: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('v1EventsEventIdDelete', 'eventId', eventId)
            const localVarPath = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('v1EventsEventIdGet', 'eventId', eventId)
            const localVarPath = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event
         * @param {string} eventId 
         * @param {V1EventsEventIdPutRequest} v1EventsEventIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdPut: async (eventId: string, v1EventsEventIdPutRequest: V1EventsEventIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('v1EventsEventIdPut', 'eventId', eventId)
            // verify required parameter 'v1EventsEventIdPutRequest' is not null or undefined
            assertParamExists('v1EventsEventIdPut', 'v1EventsEventIdPutRequest', v1EventsEventIdPutRequest)
            const localVarPath = `/v1/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1EventsEventIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new event (class)
         * @param {V1EventsPostRequest} v1EventsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsPost: async (v1EventsPostRequest: V1EventsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v1EventsPostRequest' is not null or undefined
            assertParamExists('v1EventsPost', 'v1EventsPostRequest', v1EventsPostRequest)
            const localVarPath = `/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1EventsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EventsEventIdDelete(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1EventsEventIdDelete(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.v1EventsEventIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1EventsEventIdGet(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.v1EventsEventIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event
         * @param {string} eventId 
         * @param {V1EventsEventIdPutRequest} v1EventsEventIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EventsEventIdPut(eventId: string, v1EventsEventIdPutRequest: V1EventsEventIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1EventsEventIdPut(eventId, v1EventsEventIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.v1EventsEventIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new event (class)
         * @param {V1EventsPostRequest} v1EventsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EventsPost(v1EventsPostRequest: V1EventsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1EventsPost(v1EventsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.v1EventsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdDelete(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1EventsEventIdDelete(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.v1EventsEventIdGet(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event
         * @param {string} eventId 
         * @param {V1EventsEventIdPutRequest} v1EventsEventIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsEventIdPut(eventId: string, v1EventsEventIdPutRequest: V1EventsEventIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.v1EventsEventIdPut(eventId, v1EventsEventIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new event (class)
         * @param {V1EventsPostRequest} v1EventsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EventsPost(v1EventsPostRequest: V1EventsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.v1EventsPost(v1EventsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Delete an event
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public v1EventsEventIdDelete(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).v1EventsEventIdDelete(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an event by ID
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public v1EventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).v1EventsEventIdGet(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event
     * @param {string} eventId 
     * @param {V1EventsEventIdPutRequest} v1EventsEventIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public v1EventsEventIdPut(eventId: string, v1EventsEventIdPutRequest: V1EventsEventIdPutRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).v1EventsEventIdPut(eventId, v1EventsEventIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new event (class)
     * @param {V1EventsPostRequest} v1EventsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public v1EventsPost(v1EventsPostRequest: V1EventsPostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).v1EventsPost(v1EventsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdDelete: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('v1GroupsGroupIdDelete', 'groupId', groupId)
            const localVarPath = `/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('v1GroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group
         * @param {string} groupId 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdPut: async (groupId: string, group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('v1GroupsGroupIdPut', 'groupId', groupId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('v1GroupsGroupIdPut', 'group', group)
            const localVarPath = `/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsPost: async (group: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('v1GroupsPost', 'group', group)
            const localVarPath = `/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GroupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GroupsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.v1GroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GroupsGroupIdDelete(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.v1GroupsGroupIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GroupsGroupIdGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.v1GroupsGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a group
         * @param {string} groupId 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GroupsGroupIdPut(groupId: string, group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GroupsGroupIdPut(groupId, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.v1GroupsGroupIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GroupsPost(group: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GroupsPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.v1GroupsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Group>> {
            return localVarFp.v1GroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1GroupsGroupIdDelete(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.v1GroupsGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group
         * @param {string} groupId 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsGroupIdPut(groupId: string, group: Group, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.v1GroupsGroupIdPut(groupId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GroupsPost(group: Group, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.v1GroupsPost(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public v1GroupsGet(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).v1GroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public v1GroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).v1GroupsGroupIdDelete(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a group by ID
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public v1GroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).v1GroupsGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group
     * @param {string} groupId 
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public v1GroupsGroupIdPut(groupId: string, group: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).v1GroupsGroupIdPut(groupId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public v1GroupsPost(group: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).v1GroupsPost(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a weekly schedule based on the current groups, subjects, and teachers
         * @param {GenerateScheduleRequest} generateScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGeneratePost: async (generateScheduleRequest: GenerateScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateScheduleRequest' is not null or undefined
            assertParamExists('v1SchedulesGeneratePost', 'generateScheduleRequest', generateScheduleRequest)
            const localVarPath = `/v1/schedules/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all schedules for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new schedule
         * @param {V1SchedulesPostRequest} v1SchedulesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesPost: async (v1SchedulesPostRequest: V1SchedulesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v1SchedulesPostRequest' is not null or undefined
            assertParamExists('v1SchedulesPost', 'v1SchedulesPostRequest', v1SchedulesPostRequest)
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1SchedulesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdDelete: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdGet: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a schedule
         * @param {string} scheduleId 
         * @param {V1SchedulesScheduleIdPutRequest} v1SchedulesScheduleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPut: async (scheduleId: string, v1SchedulesScheduleIdPutRequest: V1SchedulesScheduleIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPut', 'scheduleId', scheduleId)
            // verify required parameter 'v1SchedulesScheduleIdPutRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPut', 'v1SchedulesScheduleIdPutRequest', v1SchedulesScheduleIdPutRequest)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1SchedulesScheduleIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate a weekly schedule based on the current groups, subjects, and teachers
         * @param {GenerateScheduleRequest} generateScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesGeneratePost(generateScheduleRequest: GenerateScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesGeneratePost(generateScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all schedules for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new schedule
         * @param {V1SchedulesPostRequest} v1SchedulesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesPost(v1SchedulesPostRequest: V1SchedulesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesPost(v1SchedulesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdDelete(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesScheduleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdGet(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a schedule
         * @param {string} scheduleId 
         * @param {V1SchedulesScheduleIdPutRequest} v1SchedulesScheduleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdPut(scheduleId: string, v1SchedulesScheduleIdPutRequest: V1SchedulesScheduleIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdPut(scheduleId, v1SchedulesScheduleIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.v1SchedulesScheduleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate a weekly schedule based on the current groups, subjects, and teachers
         * @param {GenerateScheduleRequest} generateScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGeneratePost(generateScheduleRequest: GenerateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.v1SchedulesGeneratePost(generateScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all schedules for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Schedule>> {
            return localVarFp.v1SchedulesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new schedule
         * @param {V1SchedulesPostRequest} v1SchedulesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesPost(v1SchedulesPostRequest: V1SchedulesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.v1SchedulesPost(v1SchedulesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdDelete(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.v1SchedulesScheduleIdGet(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a schedule
         * @param {string} scheduleId 
         * @param {V1SchedulesScheduleIdPutRequest} v1SchedulesScheduleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPut(scheduleId: string, v1SchedulesScheduleIdPutRequest: V1SchedulesScheduleIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.v1SchedulesScheduleIdPut(scheduleId, v1SchedulesScheduleIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
    /**
     * 
     * @summary Generate a weekly schedule based on the current groups, subjects, and teachers
     * @param {GenerateScheduleRequest} generateScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesGeneratePost(generateScheduleRequest: GenerateScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesGeneratePost(generateScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all schedules for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesGet(options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new schedule
     * @param {V1SchedulesPostRequest} v1SchedulesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesPost(v1SchedulesPostRequest: V1SchedulesPostRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesPost(v1SchedulesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a schedule
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesScheduleIdDelete(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a schedule by ID
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesScheduleIdGet(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a schedule
     * @param {string} scheduleId 
     * @param {V1SchedulesScheduleIdPutRequest} v1SchedulesScheduleIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public v1SchedulesScheduleIdPut(scheduleId: string, v1SchedulesScheduleIdPutRequest: V1SchedulesScheduleIdPutRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).v1SchedulesScheduleIdPut(scheduleId, v1SchedulesScheduleIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubjectsApi - axios parameter creator
 * @export
 */
export const SubjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all subjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subjects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new subject
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsPost: async (subject: Subject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('v1SubjectsPost', 'subject', subject)
            const localVarPath = `/v1/subjects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a subject
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdDelete: async (subjectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectId' is not null or undefined
            assertParamExists('v1SubjectsSubjectIdDelete', 'subjectId', subjectId)
            const localVarPath = `/v1/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdGet: async (subjectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectId' is not null or undefined
            assertParamExists('v1SubjectsSubjectIdGet', 'subjectId', subjectId)
            const localVarPath = `/v1/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subject
         * @param {string} subjectId 
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdPut: async (subjectId: string, subject: Subject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectId' is not null or undefined
            assertParamExists('v1SubjectsSubjectIdPut', 'subjectId', subjectId)
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('v1SubjectsSubjectIdPut', 'subject', subject)
            const localVarPath = `/v1/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubjectsApi - functional programming interface
 * @export
 */
export const SubjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all subjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubjectsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubjectsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.v1SubjectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new subject
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubjectsPost(subject: Subject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubjectsPost(subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.v1SubjectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a subject
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubjectsSubjectIdDelete(subjectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubjectsSubjectIdDelete(subjectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.v1SubjectsSubjectIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubjectsSubjectIdGet(subjectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubjectsSubjectIdGet(subjectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.v1SubjectsSubjectIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a subject
         * @param {string} subjectId 
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubjectsSubjectIdPut(subjectId: string, subject: Subject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubjectsSubjectIdPut(subjectId, subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.v1SubjectsSubjectIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubjectsApi - factory interface
 * @export
 */
export const SubjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all subjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Subject>> {
            return localVarFp.v1SubjectsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new subject
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsPost(subject: Subject, options?: RawAxiosRequestConfig): AxiosPromise<Subject> {
            return localVarFp.v1SubjectsPost(subject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a subject
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdDelete(subjectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SubjectsSubjectIdDelete(subjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {string} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdGet(subjectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Subject> {
            return localVarFp.v1SubjectsSubjectIdGet(subjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subject
         * @param {string} subjectId 
         * @param {Subject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubjectsSubjectIdPut(subjectId: string, subject: Subject, options?: RawAxiosRequestConfig): AxiosPromise<Subject> {
            return localVarFp.v1SubjectsSubjectIdPut(subjectId, subject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubjectsApi - object-oriented interface
 * @export
 * @class SubjectsApi
 * @extends {BaseAPI}
 */
export class SubjectsApi extends BaseAPI {
    /**
     * 
     * @summary Get all subjects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public v1SubjectsGet(options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).v1SubjectsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new subject
     * @param {Subject} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public v1SubjectsPost(subject: Subject, options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).v1SubjectsPost(subject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a subject
     * @param {string} subjectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public v1SubjectsSubjectIdDelete(subjectId: string, options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).v1SubjectsSubjectIdDelete(subjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a subject by ID
     * @param {string} subjectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public v1SubjectsSubjectIdGet(subjectId: string, options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).v1SubjectsSubjectIdGet(subjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subject
     * @param {string} subjectId 
     * @param {Subject} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public v1SubjectsSubjectIdPut(subjectId: string, subject: Subject, options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).v1SubjectsSubjectIdPut(subjectId, subject, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeachersApi - axios parameter creator
 * @export
 */
export const TeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all teachers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new teacher
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersPost: async (teacher: Teacher, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teacher' is not null or undefined
            assertParamExists('v1TeachersPost', 'teacher', teacher)
            const localVarPath = `/v1/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teacher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a teacher
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdDelete: async (teacherId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teacherId' is not null or undefined
            assertParamExists('v1TeachersTeacherIdDelete', 'teacherId', teacherId)
            const localVarPath = `/v1/teachers/{teacherId}`
                .replace(`{${"teacherId"}}`, encodeURIComponent(String(teacherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a teacher by ID
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdGet: async (teacherId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teacherId' is not null or undefined
            assertParamExists('v1TeachersTeacherIdGet', 'teacherId', teacherId)
            const localVarPath = `/v1/teachers/{teacherId}`
                .replace(`{${"teacherId"}}`, encodeURIComponent(String(teacherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a teacher
         * @param {string} teacherId 
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdPut: async (teacherId: string, teacher: Teacher, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teacherId' is not null or undefined
            assertParamExists('v1TeachersTeacherIdPut', 'teacherId', teacherId)
            // verify required parameter 'teacher' is not null or undefined
            assertParamExists('v1TeachersTeacherIdPut', 'teacher', teacher)
            const localVarPath = `/v1/teachers/{teacherId}`
                .replace(`{${"teacherId"}}`, encodeURIComponent(String(teacherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teacher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeachersApi - functional programming interface
 * @export
 */
export const TeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all teachers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TeachersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TeachersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeachersApi.v1TeachersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new teacher
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TeachersPost(teacher: Teacher, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TeachersPost(teacher, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeachersApi.v1TeachersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a teacher
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TeachersTeacherIdDelete(teacherId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TeachersTeacherIdDelete(teacherId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeachersApi.v1TeachersTeacherIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a teacher by ID
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TeachersTeacherIdGet(teacherId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TeachersTeacherIdGet(teacherId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeachersApi.v1TeachersTeacherIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a teacher
         * @param {string} teacherId 
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TeachersTeacherIdPut(teacherId: string, teacher: Teacher, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TeachersTeacherIdPut(teacherId, teacher, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeachersApi.v1TeachersTeacherIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeachersApi - factory interface
 * @export
 */
export const TeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all teachers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Teacher>> {
            return localVarFp.v1TeachersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new teacher
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersPost(teacher: Teacher, options?: RawAxiosRequestConfig): AxiosPromise<Teacher> {
            return localVarFp.v1TeachersPost(teacher, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a teacher
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdDelete(teacherId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1TeachersTeacherIdDelete(teacherId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a teacher by ID
         * @param {string} teacherId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdGet(teacherId: string, options?: RawAxiosRequestConfig): AxiosPromise<Teacher> {
            return localVarFp.v1TeachersTeacherIdGet(teacherId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a teacher
         * @param {string} teacherId 
         * @param {Teacher} teacher 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TeachersTeacherIdPut(teacherId: string, teacher: Teacher, options?: RawAxiosRequestConfig): AxiosPromise<Teacher> {
            return localVarFp.v1TeachersTeacherIdPut(teacherId, teacher, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
export class TeachersApi extends BaseAPI {
    /**
     * 
     * @summary Get all teachers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public v1TeachersGet(options?: RawAxiosRequestConfig) {
        return TeachersApiFp(this.configuration).v1TeachersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new teacher
     * @param {Teacher} teacher 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public v1TeachersPost(teacher: Teacher, options?: RawAxiosRequestConfig) {
        return TeachersApiFp(this.configuration).v1TeachersPost(teacher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a teacher
     * @param {string} teacherId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public v1TeachersTeacherIdDelete(teacherId: string, options?: RawAxiosRequestConfig) {
        return TeachersApiFp(this.configuration).v1TeachersTeacherIdDelete(teacherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a teacher by ID
     * @param {string} teacherId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public v1TeachersTeacherIdGet(teacherId: string, options?: RawAxiosRequestConfig) {
        return TeachersApiFp(this.configuration).v1TeachersTeacherIdGet(teacherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a teacher
     * @param {string} teacherId 
     * @param {Teacher} teacher 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public v1TeachersTeacherIdPut(teacherId: string, teacher: Teacher, options?: RawAxiosRequestConfig) {
        return TeachersApiFp(this.configuration).v1TeachersTeacherIdPut(teacherId, teacher, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersLoginPost: async (userLogin: UserLogin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLogin' is not null or undefined
            assertParamExists('v1UsersLoginPost', 'userLogin', userLogin)
            const localVarPath = `/v1/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersRegisterPost: async (userRegistration: UserRegistration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegistration' is not null or undefined
            assertParamExists('v1UsersRegisterPost', 'userRegistration', userRegistration)
            const localVarPath = `/v1/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersLoginPost(userLogin: UserLogin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UsersLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersLoginPost(userLogin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1UsersLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersRegisterPost(userRegistration: UserRegistration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersRegisterPost(userRegistration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.v1UsersRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersLoginPost(userLogin: UserLogin, options?: RawAxiosRequestConfig): AxiosPromise<V1UsersLoginPost200Response> {
            return localVarFp.v1UsersLoginPost(userLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersRegisterPost(userRegistration: UserRegistration, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.v1UsersRegisterPost(userRegistration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary User login
     * @param {UserLogin} userLogin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersLoginPost(userLogin: UserLogin, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersLoginPost(userLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {UserRegistration} userRegistration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersRegisterPost(userRegistration: UserRegistration, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersRegisterPost(userRegistration, options).then((request) => request(this.axios, this.basePath));
    }
}



